<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <link rel="stylesheet" href="style.css">
        <!--TODO: Need to access D3 in the console?-->
        <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    </head>
    
    <body>
        <div class="bar"></div> 

        <h1>Learning D3</h1>
        <button type="button">Click to update bar chart</button>
        <div class="empty"></div>
        
        <script type="module">
            import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
            console.log("Imported D3");
            
            var dataset = [
                20, 13, 22, 21, 44, 15, 39, 9, 25, 18
            ];
            //var dataset = []
            //for (var i=0; i<25; i++) {
            //    // Generate a random number between 0 and 100
            //    var d = Math.random() * 100;
            //    dataset.push(d);
            //}
            //d3.select("body").selectAll("p")
            //    .data(dataset)
            //    .enter()
            //    .append("div")
            //    .attr("class", "bar")
            //    .style("height", function(d) {
            //        var barHeight = d*5; // scale the height for visibility
            //        return barHeight + "px";
            //    })
            //    .style("background-color", function(d) {
            //        if (d > 50) {
            //            return "#cc5555"; // a nicer red
            //        } else {
            //            return "teal";
            //        }
            //    });
            
            // Create an SVG element inside the DOM body element
            var svgWidth = 800;
            var svgHeight = 500;
            var barPadding = 1;
            var svg = d3.select("body")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("style", "outline: thin solid #dedede");

            // Select all the *future* rectangles that will be created
            svg.selectAll("rect")
                .data(dataset)  // dataset is passed onto enter()
                .enter()        // which creates an empty reference to each data value
                .append("rect") // Creates a rectangle for each data value
                .attr("x", function(data, index) {
                    return index * (svgWidth / dataset.length);
                })   // Apply the following attributes to each rectangle
                .attr("y", function(data, index) {
                    return svgHeight - (data*4);
                })
                .attr("width", function(data, index) {
                    return (svgWidth / dataset.length) - barPadding;
                })
                .attr("height", function(data, index) {
                    return data*4;
                })
                .attr("fill", function(data, index) {
                    return "rgb(" + Math.round(data*10) + ", 0, 0)";
                });

            // Selects all *future* text that will be created
            svg.selectAll("text")
                .data(dataset) // the dataset to be passed into enter()
                .enter()
                .append("text") // Creates an empty reference to a text object for this data value
                .text(function(data, index) { // Not set via attr()
                    return data;
                })
                .attr("x", function(data, index) {
                    // Set the label to be positioned in the middle of the bar
                    let barWidth = (svgWidth / dataset.length) - barPadding;
                    return index * (svgWidth / dataset.length) + (barWidth / 2); // padding
                })
                .attr("y", function(data, index) {
                    return svgHeight - (data*4) + 20; // +20 padding
                })
                .attr("fill", "white")
                .attr("font-size", "12px")
                .attr("font-family", "sans-serif")
                .attr("text-anchor", "middle"); // set label to be in the middle

            //var dataset = [5, 10, 15, 20, 25];
            //// Create circle elements inside the SVG element
            //var circles = svg.selectAll("circle") // returns a reference to empty Circle elements
            //    .data(dataset) // Binds each data item in `dataset` to each Circle element
            //    .enter() // Return a reference to the new element
            //    .append("circle"); // Add circle to the DOM

            //// Apply styles to each Circle, depending on the binded data item
            //circles.attr("cx", function(d, i) { // d=data element, i=index
            //        return (i*50) + 25;
            //    })
            //    .attr("cy", height/2)
            //    .attr("r", function(d) {
            //        return d;
            //    })
            //    .attr("fill", function(d) {
            //        if (d%10 == 0) {
            //            return "#db7fef";
            //        } else {
            //            return "#91ebf7";
            //        }
            //    })
            //    .attr("stroke", "#d3f9ff")
            //    .attr("stroke-width", 5);
           
            // Scatterplot dataset
            var dataset = [
                [134, 223],
                [208, 117],
                [121, 55],
                [311, 211],
                [145, 131],
                [212, 17],
                [800, 400]
            ];
            // Create the SVG element in the DOM
            var svg = d3.select("body")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("style", "outline: thin solid #dedede");
            
            // Create scales that will ensure that the points always fit in the SVG object
            // We fit the dataset values to the width and height of the SVG
            var padding = 100;
            var xScale = d3.scaleLinear()
                // Across the dataset, compare each value's first element with each other
                .domain([0, d3.max(dataset, function(data) { return data[0]; })])
                // Map the dataset x-values to the bounds of the SVG's width
                .range([padding, svgWidth - padding]);
            var yScale = d3.scaleLinear()
                .domain([0, d3.max(dataset, function(data) { return data[1]})])
                .range([svgHeight - padding, padding]);

            var aScale = d3.scaleSqrt()
                .domain([0, d3.max(dataset, function(data) { return data[1]; })])
                .range([0, 10]); // Range is arbitrary - what matters is that the circle areas are relative
            
            // For each datapoint, we create a circle
            svg.selectAll("circle") // Get a reference to all *future* circles that will be created
                .data(dataset)      // Get the dataset to be applied to each circle
                .enter()            // Pass in `dataset` to enter()
                .append("circle")   // Create the actual circle
                .attr("cx", function(data, index) {
                    return xScale(data[0]);
                })
                .attr("cy", function(data, index) {
                    return yScale(data[1]);
                })
                .attr("fill", "black")
                .attr("r", function(data, index) {
                    return aScale(data[1]);
                });

            // Labels for each point in the scatterplot
            svg.selectAll("text")
                .data(dataset)
                .enter()
                .append("text")
                .text(function(data, index) {
                    return "(" + data[0] + ", " + data[1] + ")";
                })
                .attr("x", function(data, index) {
                    return xScale(data[0]);
                })
                .attr("y", function(data, index) {
                    return yScale(data[1]) + 20; // padding 
                })
                .attr("text-anchor", "middle");

            var timeParser = d3.timeParse("%m/%d/%y");
            var csvRowConverter = function(row) {
                return {
                    date: timeParser(row.Date),
                    amount: parseInt(row.Amount)
                };
            };
            var dataset = await d3.csv("data/time_scale_data.csv", csvRowConverter)
                .then(function(parsedData) {
                    console.log(parsedData);
                    return parsedData;
                });
            
            // Plot the time_scale_data in a separate CSV object
            var svg = d3.select("body")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("style", "outline: thin solid #dedede");
            
            // Use scaleTime() to map `Date` objects to pixel values
            // x-values of dates
            // Create new Date objects, otherwise a reference to the dataset is given
            // (which then we modify the min/max Date values)
            var minDate = new Date(d3.min(dataset, function(data) { return data.date; }));
            minDate.setDate(minDate.getDate() - 1);
            var maxDate = new Date(d3.max(dataset, function(data) { return data.date; }));
            maxDate.setDate(maxDate.getDate() + 1) 
            var xScale = d3.scaleTime()
                .domain([minDate, maxDate])
                .range([
                    padding, svgWidth - padding
                ]);
            // y-values of amounts
            var yScale = d3.scaleLinear()
                .domain([
                    d3.min(dataset, function(data) { return data.amount; }) - 10,   // padding
                    d3.max(dataset, function(data) { return data.amount; }) + 10    // padding
                ])
                .range([
                    svgHeight - padding, padding
                ]);
            // let size of circle depend on amount value
            var areaScale = d3.scaleSqrt()
                .domain([0, d3.max(dataset, function(data) { return data.amount; })])
                .range([0, 10]); // Range is arbitrary - what matters is that the circle areas are relative
            
            svg.selectAll("circle")
                .data(dataset)
                .enter()
                .append("circle")
                .attr("cx", function(data, index) {
                    return xScale(data.date);
                })
                .attr("cy", function(data, index) {
                    return yScale(data.amount);
                })
                .attr("r", function(data, index) {
                    return areaScale(data.amount);
                })
                .attr("fill", "pink");
            
            // Display date/amount value for each circle
            var formatTime = d3.timeFormat("%a, %e");
            svg.selectAll("text")
                .data(dataset)
                .enter()
                .append("text")
                .text(function(data, index) { return formatTime(data.date); })
                .attr("x", function(data, index) { return xScale(data.date); })
                .attr("y", function(data, index) {
                    return yScale(data.amount) + 25; // padding
                })
                .attr("text-anchor", "middle")
                .attr("font-size", "14")
                .attr("fill", "#736272")
                .attr("font-family", "sans-serif");
            
            var timeFormat = d3.timeFormat("%b %d");
            var xAxis = d3.axisBottom(xScale)
                .tickFormat(timeFormat)
                .ticks(5);
            // This does not work...
            //.tickValues([
            //    xScale(Date(2025, 12, 18)),
            //    xScale(Date(2025, 12, 19)),
            //    xScale(Date(2025, 12, 27))
            //]);
            svg.append("g") // SVG group
                .attr("class", "axis")  // Name the SVG group to axis"
                .attr("transform", "translate(0, " + (svgHeight - padding) + ")")
                .call(xAxis); // Passes the `g` SVG element to xAxis()
            
            // Create a separate SVG group for the y-axis
            var yAxis = d3.axisLeft(yScale);
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (padding) + ", 0)")
                .call(yAxis);
            
            // Make a random dataset and plot a scatterplot
            var dataset = [];
            var xMax = 100;
            var yMax = 100;
            var numPoints = 50;
            for (var i=0; i<numPoints; i++) {
                var x = Math.floor(Math.random() * xMax);
                var y = Math.floor(Math.random() * yMax);
                dataset.push([x, y]);
            }
            
            // Create scales for x and y values
            var svgPadding = 50;
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(dataset, function(p) { return p[0]; }),
                    d3.max(dataset, function(p) { return p[0]; })
                ]) //
                .range([svgPadding, svgWidth - svgPadding]); // which pixel in the SVG to map to
           
            var yScale = d3.scaleLinear()
                .domain([
                    d3.min(dataset, function(p) { return p[0]; }),
                    d3.max(dataset, function(p) { return p[0]; })
                ])
                .range([svgHeight - svgPadding, svgPadding]);

            var svg = d3.select("body")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("style", "outline: thin solid #dedede");
            
            svg.selectAll("circle")
                .data(dataset)
                .enter()
                .append("circle")
                .attr("cx", function(data, index) {
                    return xScale(data[0]);
                })
                .attr("cy", function(data, index) {
                    return yScale(data[1]);
                })
                .attr("r", 3)
                .attr("fill", "#c46021"); 

            var xAxis = d3.axisBottom(xScale);
            svg.append("g") // SVG group
                .attr("class", "axis")  // Name the SVG group to axis"
                .attr("transform", "translate(0, " + (svgHeight - svgPadding + 15) + ")")
                .call(xAxis); // Passes the `g` SVG element to xAxis()
            
            var yAxis = d3.axisLeft(yScale);
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (svgPadding) + ", 15)")
                .call(yAxis);
            
            // Revisit the bar chart
            var dataset = [
                20, 13, 22, 21, 44, 15, 39, 9, 25, 18
            ];
           
            var svgWidth = 900;
            var svgHeight = 400;
            var svgPadding = 5;
            var labelPadding = 30;
            var svg = d3.select("body")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("style", "outline: thin solid #dedede");

            // Create an ordinal scale to handle positioning of bars
            // and their labels
            var xScale = d3.scaleBand()
                .domain(d3.range(dataset.length)) // creates an array [0, 1, 2, ..., dataset.length-1]
                .range([0, svgWidth])
                .paddingInner(0.05);

            var yScale = d3.scaleLinear()
                .domain([
                    d3.min(dataset),
                    d3.max(dataset)
                ])
                .range([
                    svgPadding, svgHeight - svgPadding 
                ]);

            // Select all the *future* rectangles that will be created
            svg.selectAll("rect")
                .data(dataset)  // dataset is passed onto enter()
                .enter()        // which creates an empty reference to each data value
                .append("rect") // Creates a rectangle for each data value
                .attr("x", function(data, index) {
                    return xScale(index);
                })   // Apply the following attributes to each rectangle
                .attr("y", function(data, index) {
                    return svgHeight - yScale(data);
                })
                .attr("width", xScale.bandwidth())
                .attr("height", function(data, index) {
                    return yScale(data);
                })
                .attr("fill", function(data, index) {
                    return "rgb(0, 0, " + Math.round(data*10) + ")";
                });

            // Selects all *future* text that will be created
            svg.selectAll("text")
                .data(dataset) // the dataset to be passed into enter()
                .enter()
                .append("text") // Creates an empty reference to a text object for this data value
                .text(function(data, index) { // Not set via attr()
                    return data;
                })
                .attr("x", function(data, index) {
                    return xScale(index) + xScale.bandwidth()/2;
                })
                .attr("y", function(data, index) {
                    return svgHeight - yScale(data) + labelPadding;
                })
                .attr("fill", "white")
                .attr("font-size", "12px")
                .attr("font-family", "sans-serif")
                .attr("text-anchor", "middle"); // set label to be in the middle

            // Create an event handler for re-loading new data into the bar chart
            var button = d3.select("body").append("button").text("Click!").attr("type", "button");
            var numDataValues = dataset.length;
            var dataMin = 0;
            var dataMax = 100;
            var animationDuration = 300; // miliseconds
            button.on("click", function() {
                console.log("The button was clicked!");
                var dataset = [];
                for (var i=0; i<numDataValues; i++) {
                    dataset.push(Math.floor(Math.random() * dataMax - dataMin + 1) + dataMin)
                } 
                console.log(
                    "New dataset: ", dataset
                ) 
                
                // Update the scale to adjust to the new dataset
                yScale.domain([0, d3.max(dataset)]);
                
                svg.selectAll("rect")
                    .data(dataset) // Bind the new dataset
                    .transition()
                    .delay(function(data, index) {
                        return (index / dataset.length) * animationDuration; // miliseconds
                    })
                    .duration(1000) // duration of each bar
                    .ease(d3.easeLinear)
                    .attr("y", function(d, i) {
                        return svgHeight - yScale(d);
                    })
                    .attr("height", function(d, i) {
                        return yScale(d);
                    });
                
                // Update the labels
                svg.selectAll("text")
                    .data(dataset) // the dataset to be passed into enter()
                    .transition()
                    .delay(function(data, index) {
                        return (index / dataset.length) * animationDuration; // miliseconds
                    })
                    .duration(1000)
                    .ease(d3.easeLinear)
                    .text(function(data, index) { // Not set via attr()
                        return data;
                    })
                    .attr("y", function(data, index) {
                        var barHeight = yScale(data);
                        //console.log("Bar height for " + data + " is " + barHeight);
                        if (barHeight < 50) {
                            return svgHeight - barHeight - 10;
                        } else {
                            return svgHeight - barHeight + labelPadding;
                        }
                    })
                    .attr("fill", function(data, index) {
                        var barHeight = yScale(data);
                        if (barHeight < 50) {
                            return "black";
                        } else {
                            return "white";
                        }
                    });
            })
          
            // Generate another scatterplot with data
            var svgPadding = 50;
            var dataset = [];
            var xMin = 0;
            var xMax = 100;
            var yMin = 0;
            var yMax = 100;
            var numPoints = 50;
            
            var svg = d3.select("body")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .attr("style", "outline: thin solid #dedede");
            for (var i=0; i<numPoints; i++) {
                var x = Math.floor(Math.random() * xMax - xMin + 1) + xMin;
                var y = Math.floor(Math.random() * yMax - yMin + 1) + yMin;
                dataset.push([x, y]);
            }
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(dataset, function(p) { return p[0]; }),
                    d3.max(dataset, function(p) { return p[0]; })
                ]) //
                .range([svgPadding, svgWidth - svgPadding]); // which pixel in the SVG to map to
           
            var yScale = d3.scaleLinear()
                .domain([
                    d3.min(dataset, function(p) { return p[0]; }),
                    d3.max(dataset, function(p) { return p[0]; })
                ])
                .range([svgHeight - svgPadding, svgPadding]);
            
            var xAxis = d3.axisBottom(xScale);
            svg.append("g") // SVG group
                .attr("class", "x axis")  // Name the SVG group to axis"
                .attr("transform", "translate(0, " + (svgHeight - svgPadding + 15) + ")")
                .call(xAxis); // Passes the `g` SVG element to xAxis()
            
            var yAxis = d3.axisLeft(yScale);
            svg.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(" + (svgPadding) + ", 15)")
                .call(yAxis);

            // Create scales for x and y values
            svg.selectAll("circle")
                .data(dataset)
                .enter()
                .append("circle")
                .attr("cx", function(data, index) {
                    return xScale(data[0]);
                })
                .attr("cy", function(data, index) {
                    return yScale(data[1]);
                })
                .attr("r", 3)
                .attr("fill", "#c46021"); 
            
            function generate_dynamic_scatterplot(svg) {
                var dataset = []
                for (var i=0; i<numPoints; i++) {
                    var x = Math.floor(Math.random() * xMax - xMin + 1) + xMin;
                    var y = Math.floor(Math.random() * yMax - yMin + 1) + yMin;
                    dataset.push([x, y]);
                }
                
                // Update scales for x and y values
                xScale
                    .domain([
                        d3.min(dataset, function(p) { return p[0]; }),
                        d3.max(dataset, function(p) { return p[0]; })
                    ]) //
                    .range([svgPadding, svgWidth - svgPadding]); // which pixel in the SVG to map to
           
                yScale
                    .domain([
                        d3.min(dataset, function(p) { return p[0]; }),
                        d3.max(dataset, function(p) { return p[0]; })
                    ])
                    .range([svgHeight - svgPadding, svgPadding]);

                svg.selectAll("circle")
                    .data(dataset)
                    .transition() // Transition #1
                    .on("start", function() {
                        d3.select(this)
                            //.transition()
                            //.duration(250)
                            .attr("fill", "blue")
                            .attr("r", 10)
                    })
                    .attr("cx", function(data, index) {
                        return xScale(data[0]);
                    })
                    .attr("cy", function(data, index) {
                        return yScale(data[1]);
                    })
                    .attr("r", 3)
                    .attr("fill", "#c46021")
                    .transition() // Transition #2
                    .duration(1000)
                    .attr("fill", "orange")
                    .attr("r", 20);
                
                // Update the axes
                svg.select(".x.axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                svg.select(".y.axis")
                    .transition()
                    .duration(1000)
                    .call(yAxis);
            } // generate_dynamic_scatterplot()
            
            var button = d3.select("body")
                .append("button")
                .text("Click on me!")
                .attr("type", "button");
            button.on("click", function() {
                generate_dynamic_scatterplot(svg);
            });

        </script>
    </body>
    
</html>
